/*
 *  Project   : tin - a Usenet reader
 *  Module    : makecfg.c
 *  Author    : Thomas E. Dickey <dickey@clark.net>
 *  Created   : 01.11.96
 *  Updated   :
 *  Notes     : #defines and structs for config.c
 *  Copyright 1996 by Thomas E. Dickey
 *              You may  freely  copy or  redistribute  this software,
 *              so  long as there is no profit made from its use, sale
 *              trade or  reproduction.  You may not change this copy-
 *              right notice, and it must be included in any copy made
 */

#include "tin.h"

#define MYDATA struct mydata
MYDATA {
	MYDATA *link;
	char *name;
	char *type;
	char *size;
};

static char *string_dup P_ ((char *string));
static void failed P_ ((char *name));
static void generate_tbl P_ ((FILE * ofp));
static void makecfg P_ ((FILE * input, FILE * output));
static FILE *open_it P_ ((char *filename, char *mode));
static void parse_tbl P_ ((char *buffer));
static void store_data P_ ((char *name, char *type, char *size));
static void write_it P_ ((FILE * ofp, char **table));

static MYDATA *all_data;
static int line_no;

static void
failed (message)
	char *message;
{
	perror (message);
	exit (1);
}

static FILE *
open_it (filename, mode)
	char *filename;
	char *mode;
{
	FILE *fp = fopen (filename, mode);

	if (fp == 0)
		failed (filename);
	return fp;
}

static char *
string_dup (string)
	char *string;
{
	return strcpy (malloc (strlen (string) + 1), string);
}

static void
store_data (name, type, size)
	char *name;
	char *type;
	char *size;
{
	MYDATA *p = (MYDATA *) malloc (sizeof (MYDATA));
	MYDATA *q;

	p->link = 0;
	p->name = string_dup (name);
	p->type = string_dup (type);
	p->size = string_dup (size);

	if ((q = all_data) == 0)
		all_data = p;
	else {
		while (q->link != 0)
			q = q->link;
		q->link = p;
	}
}

static void
parse_tbl (buffer)
	char *buffer;
{
	char *s = buffer;
	char *t = s + strlen (s);

	/* strip leading/trailing blanks */
	while ((t-- != s) && isspace (*t))
		*t = '\0';
	while (isspace (*s))
		s++;
	buffer = s;

	line_no++;
	if (*buffer != ';' && *buffer != '\0') {	/* ignore comments */
		if (*buffer == '#') {
			store_data (buffer, "", "");
		} else {
			/* otherwise the data consists of up to 3 blank
			 * separated columns (name, type, size).
			 */
			while (*s && !isspace (*s))
				s++;
			while (isspace (*s))
				*s++ = '\0';
			t = s;
			while (*t && !isspace (*t))
				t++;
			while (isspace (*t))
				*t++ = '\0';
			store_data (buffer, s, t);
		}
	}
}

static void
write_it (ofp, table)
	FILE *ofp;
	char **table;
{
	int n;

	for (n = 0; table[n] != 0; n++)
		fprintf (ofp, "%s\n", table[n]);
}

static void
generate_tbl (ofp)
	FILE *ofp;
{
	static char *table_1[] =
	{
		"/* This file is generated by MAKECFG */"
		,""
		,"enum option_enum {"
		,"\tOPT_VERY_FIRST = 0,"
		,0
	};
	static char *table_2[] =
	{
		"\tVERY_LAST_OPT };"
		,""
		,"#define LAST_OPT VERY_LAST_OPT - 1"
		,"#define OPT_ARG_COLUMN	9"
		,""
		,"#define OPT_ON_OFF    1"
		,"#define OPT_LIST      2"
		,"#define OPT_STRING    3"
		,"#define OPT_NUM       4"
		,"#define OPT_CHAR      5"
		,""
		,"struct t_option option_table[]={"
		,0
	};
	static char *table_3[] =
	{
		"};"
		,0
	};
	static char prefix[] = "  {(void *) ";
	static char suffix[] = "},";
	MYDATA *p;

	/* generate enumerated type */
	write_it (ofp, table_1);
	for (p = all_data; p != 0; p = p->link) {
		if (p->name[0] == '#')
			fprintf (ofp, "%s\n", p->name);
		else {
			char *s = p->name;

			fprintf (ofp, "\tOPT_");
			while (*s != '\0') {
				fprintf (ofp, "%c",
					 isalpha (*s) && islower (*s)
					 ? toupper (*s)
					 : *s);
				s++;
			}
			fprintf (ofp, ",\n");
		}
	}

	/* generate the access table */
	write_it (ofp, table_2);
	for (p = all_data; p != 0; p = p->link) {
		if (p->name[0] == '#')
			fprintf (ofp, "%s\n", p->name);
		else {
			int is_opt = !strncmp (p->type, "OPT_", 4);
			char *dft_name = p->name;

			/* shorten message-variable names */
			if (!strncmp (dft_name, "default_", 8))
				dft_name += 8;

			fprintf (ofp, "%s", prefix);
			if (strcmp (p->type, "OPT_STRING"))
				fprintf (ofp, "&");
			fprintf (ofp, "%s, ", p->name);
			fprintf (ofp, "%s, ", is_opt ? p->type : "OPT_LIST");
			if (is_opt)
				fprintf (ofp, "NULL, 0, ");
			else
				fprintf (ofp, "%s, %s, ", p->type, p->size);
			fprintf (ofp, "txt_opt_%s, ", dft_name);
			fprintf (ofp, "txt_help_%s ", dft_name);
			fprintf (ofp, "%s\n", suffix);
		}
	}

	write_it (ofp, table_3);
}

static void
makecfg (ifp, ofp)
	FILE *ifp;
	FILE *ofp;
{
	char buffer[BUFSIZ];

	/*
	 * Process the input file.
	 */
	line_no = 0;
	while (fgets (buffer, sizeof (buffer) - 1, ifp))
		parse_tbl (buffer);
	fclose (ifp);

	/*
	 * Generate the output file
	 * FIXME: this version constructs a table that matches the original
	 * all-lumped-together tables, which are not type-clean.
	 */
	generate_tbl (ofp);
	fclose (ofp);
}

int
main (argc, argv)
	int argc;
	char *argv[];
{
	FILE *input = stdin;
	FILE *output = stdout;

	if (argc > 1)
		input = open_it (argv[1], "r");
	if (argc > 2)
		output = open_it (argv[2], "w");
	makecfg (input, output);

	return (0);
}
